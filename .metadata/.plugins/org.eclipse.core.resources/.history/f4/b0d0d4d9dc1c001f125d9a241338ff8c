package windows.forms;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Point;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragGestureRecognizer;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetContext;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.io.IOException;
import java.util.Vector;

import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import session.Session;
import session.group;
import windows.actions.buttons.changestatus_button;
import windows.actions.click.contact_onclick;

public class panel_contact extends JPanel implements DropTargetListener, DragGestureListener, DragSourceListener{

	private static final long serialVersionUID = 1L;
	private JLabel Titre;
	private JLabel Soustitre;
	private JTree  tree;
	private JComboBox changstatus;
	private form_communicate comm;

	private DragSource dragSource = null;
	private DefaultMutableTreeNode selNode = null;
	public DefaultMutableTreeNode tmpNode = null;
	 DragSource source;

	  DragGestureRecognizer recognizer;

	  TransferableTreeNode transferable;

	  DefaultMutableTreeNode oldNode;

	  JTree sourceTree;
	private DefaultMutableTreeNode dropNode = null;

	
	private int status2;
	private JTextField msgperso;

	public panel_contact()
	{
		BuildPanel();
	}

	private void BuildPanel()
	{
		
		setLayout(new FlowLayout());
		setBackground(new Color(128,128,255));
		setLayout(new FlowLayout(FlowLayout.CENTER,400,10));
		
		Titre = new JLabel(Session.getPseudo());
		
		changstatus= new JComboBox();
		
		changstatus.addItem("Online");
		changstatus.addItem("Busy");
		changstatus.addItem("AFK");
		changstatus.addItem("Offline");
		changstatus.setSelectedIndex(status2);
		changstatus.addActionListener(new changestatus_button(changstatus));
		msgperso = new JTextField(20);
		msgperso.setText(Session.getPerso_msg());
		
		Soustitre = new JLabel("Liste de vos contacts : ");
		
		add(Titre);
		add(changstatus);
		add(msgperso);
		add(Soustitre);
		
		
		setlistcontact();	
		
		comm = null;
	}
	
	private void setlistcontact()
	{
		Vector<group> groups = Session.getGroups();
		
		DefaultMutableTreeNode root = new DefaultMutableTreeNode("Contactlist");
		 
		// Adding nodes
		for(int i=0;i<groups.size();i++)
		{
			DefaultMutableTreeNode tmp_grp = new DefaultMutableTreeNode(groups.get(i).getGname());
			root.add(tmp_grp);
			for(int j=0;j<groups.get(i).getContacts().size();j++)
			{
				DefaultMutableTreeNode tmp_contact = new DefaultMutableTreeNode(groups.get(i).getContacts().get(j));
				tmp_grp.add(tmp_contact);	
			}
		}
		     
		// Construction du modèle de l'arbre.
		DefaultTreeModel myModel = new DefaultTreeModel(root);
		 
		// Construction de l'arbre.
		tree = new JTree(myModel);
		
		/*
		// Construction d'un afficheur par défaut.
		DefaultTreeCellRenderer myRenderer = new DefaultTreeCellRenderer();
		 
		// Changement de l'icône pour les feuilles de l'arbre.
		myRenderer.setLeafIcon(new ImageIcon("pageIcon.png"));
		// Changement de l'icône pour les noeuds fermés.
		myRenderer.setClosedIcon(new ImageIcon("closedBookIcon.png"));
		// Changement de l'icône pour les noeuds ouverts.
		myRenderer.setOpenIcon(new ImageIcon("openBookIcon.png"));
		 
		// Application de l'afficheur à l'arbre.
		myTree.setCellRenderer(myRenderer);
		*/

		new DropTarget(tree, this);
	    dragSource = new DragSource();
	    dragSource.createDefaultDragGestureRecognizer(tree, DnDConstants.ACTION_MOVE, this);
	 
		tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.addMouseListener(new contact_onclick(tree,this));
		tree.setRootVisible(false);
		this.add(tree);
		JScrollPane Scrollbar = new JScrollPane(tree);
		Scrollbar.setPreferredSize(new Dimension(150, 300));
		this.add(Scrollbar);
	}

	public void setComm(form_communicate comm) { this.comm = comm; }
	public form_communicate getComm() { return comm; }
	
	public void ChPseudo(String n_pseudo)
	{
		Titre.setText("Pseudo : " + n_pseudo);
	}
	
	  private TreeNode getNodeForEvent(DropTargetDragEvent dtde) {
		    Point p = dtde.getLocation();
		    DropTargetContext dtc = dtde.getDropTargetContext();
		    JTree tree = (JTree) dtc.getComponent();
		    TreePath path = tree.getClosestPathForLocation(p.x, p.y);
		    return (TreeNode) path.getLastPathComponent();
		  }

	public void dragEnter(DropTargetDragEvent dtde) {
		TreeNode node = getNodeForEvent(dtde);
	    if (node.isLeaf()) {
	      dtde.rejectDrag();
	    } else {
	      // start by supporting move operations
	      //dtde.acceptDrag(DnDConstants.ACTION_MOVE);
	      dtde.acceptDrag(dtde.getDropAction());
	    }
	}

	public void dragGestureRecognized(DragGestureEvent dge) {
		TreePath path = sourceTree.getSelectionPath();
	    if ((path == null) || (path.getPathCount() <= 1)) {
	      // We can't move the root node or an empty selection
	      return;
	    }
	    oldNode = (DefaultMutableTreeNode) path.getLastPathComponent();
	    transferable = new TransferableTreeNode(path);
	    source.startDrag(dge, DragSource.DefaultMoveNoDrop, transferable, this);

	    // If you support dropping the node anywhere, you should probably
	    // start with a valid move cursor:
	    //source.startDrag(dge, DragSource.DefaultMoveDrop, transferable,
	    // this);
	}

	public void drop(DropTargetDropEvent dtde) {
		Point pt = dtde.getLocation();
	    DropTargetContext dtc = dtde.getDropTargetContext();
	    JTree tree = (JTree) dtc.getComponent();
	    TreePath parentpath = tree.getClosestPathForLocation(pt.x, pt.y);
	    DefaultMutableTreeNode parent = (DefaultMutableTreeNode) parentpath
	        .getLastPathComponent();
	    if (parent.isLeaf()) {
	      dtde.rejectDrop();
	      return;
	    }

	    try {
	      Transferable tr = dtde.getTransferable();
	      DataFlavor[] flavors = tr.getTransferDataFlavors();
	      for (int i = 0; i < flavors.length; i++) {
	        if (tr.isDataFlavorSupported(flavors[i])) {
	          dtde.acceptDrop(dtde.getDropAction());
	          TreePath p = (TreePath) tr.getTransferData(flavors[i]);
	          DefaultMutableTreeNode node = (DefaultMutableTreeNode) p
	              .getLastPathComponent();
	          DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
	          model.insertNodeInto(node, parent, 0);
	          dtde.dropComplete(true);
	          return;
	        }
	      }
	      dtde.rejectDrop();
	    } catch (Exception e) {
	      e.printStackTrace();
	      dtde.rejectDrop();
	    }
	  }
	

	public void dragDropEnd(DragSourceDropEvent e) {
		if (e.getDropSuccess()) {
		        /*if (!isNoeudParent(dropNode))
		        	dropNode = (DefaultMutableTreeNode) dropNode.getParent();
		        ((DefaultTreeModel) tree.getModel()).removeNodeFromParent(selNode);
		        ((DefaultTreeModel) tree.getModel()).insertNodeInto(selNode, dropNode, dropNode.getChildCount());
		 
		        ouvrir(dropNode);*/
			((DefaultTreeModel)tree.getModel()).removeNodeFromParent(selNode);
		    }
	}
	
	public boolean isNoeudParent(DefaultMutableTreeNode node) {
	    return (tree.isRootVisible() && tree.getRowForPath(new TreePath(node.getPath())) == 0);
	  }
	 
	public void ouvrir(DefaultMutableTreeNode node) {
	    if (node == null) return;
	 
	    if (node.isLeaf() && !isNoeudParent(node))
	      node = (DefaultMutableTreeNode) node.getParent();
	 
	    tree.expandPath(new TreePath(node.getPath()));
	  }

	public void dragExit(DropTargetEvent arg0) {
		// TODO Auto-generated method stub
	}

	public void dragOver(DropTargetDragEvent dtde) {
		TreeNode node = getNodeForEvent(dtde);
	    if (node.isLeaf()) {
	      dtde.rejectDrag();
	    } else {
	      // start by supporting move operations
	      //dtde.acceptDrag(DnDConstants.ACTION_MOVE);
	      dtde.acceptDrag(dtde.getDropAction());
	    }
	}
	public void dropActionChanged(DropTargetDragEvent arg0) {
		// TODO Auto-generated method stub
	}
	
	public void dragEnter(DragSourceDragEvent dsde) {
		// TODO Auto-generated method stub
	}

	public void dragExit(DragSourceEvent dse) {
		// TODO Auto-generated method stub
	}

	public void dragOver(DragSourceDragEvent dsde) {
		// TODO Auto-generated method stub
	}

	public void dropActionChanged(DragSourceDragEvent dsde) {
		// TODO Auto-generated method stub
	}
	
	class TransferableTreeNode implements Transferable {

		  public DataFlavor TREE_PATH_FLAVOR = new DataFlavor(TreePath.class,
		      "Tree Path");

		  DataFlavor flavors[] = { TREE_PATH_FLAVOR };

		  TreePath path;

		  public TransferableTreeNode(TreePath tp) {
		    path = tp;
		  }

		  public synchronized DataFlavor[] getTransferDataFlavors() {
		    return flavors;
		  }

		  public boolean isDataFlavorSupported(DataFlavor flavor) {
		    return (flavor.getRepresentationClass() == TreePath.class);
		  }

		  public synchronized Object getTransferData(DataFlavor flavor)
		      throws UnsupportedFlavorException, IOException {
		    if (isDataFlavorSupported(flavor)) {
		      return (Object) path;
		    } else {
		      throw new UnsupportedFlavorException(flavor);
		    }
		  }
		}
}
